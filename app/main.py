import subprocess
import json
from fastapi import FastAPI, UploadFile, File, Request
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from pathlib import Path
from modules.utils.io import convert_pdf_to_images
import markdown2

app = FastAPI()

templates = Jinja2Templates(directory="app/templates")
app.mount("/static", StaticFiles(directory="app/static"), name="static")

UPLOAD_DIR = Path("app/static/uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

# Absolute path to the btpipe.sh script
PIPELINE_SCRIPT_PATH = Path("app/btpipe.sh").absolute()


@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})


@app.post("/upload/")
async def upload_image(request: Request, file: UploadFile = File(...)):
    # Validate file type
    if file.content_type not in ["image/png", "image/jpeg", "application/pdf"]:
        return {
            "message": "Invalid file type. Only images (PNG, JPEG) and PDFs are allowed."
        }

    # Save the uploaded file
    file_path = UPLOAD_DIR / file.filename
    with open(file_path, "wb") as f:
        f.write(await file.read())

    # Log file details
    print(f"Received file: {file.filename}")

    try:
        # Run the btpipe.sh script with the image path
        result = subprocess.run(
            ["bash", str(PIPELINE_SCRIPT_PATH), str(file_path)],
            text=True,
            capture_output=True,
        )

        # Log the output of the subprocess
        print(f"STDOUT:\n{result.stdout}")
        print(f"STDERR:\n{result.stderr}")

        if result.returncode != 0:
            return {"message": f"Pipeline execution failed. Error: {result.stderr}"}

        # Read the JSON file generated by bt2.py
        output_json_file = UPLOAD_DIR / "results.json"
        if not output_json_file.exists():
            return {
                "message": "Text Analysis model did not generate the expected output."
            }

        with open(output_json_file, "r") as f:
            output_data = json.load(f)

        raw_summary = output_data.get("summary", "")
        rendered_summary = markdown2.markdown(raw_summary)  # Render markdown to HTML

        # Render result page for image files
        return templates.TemplateResponse(
            "result.html",
            {
                "request": request,
                "image_path": file.filename,  # Ensure correct name here
                "analysis": output_data.get("analysis", ""),
                "summary": rendered_summary,
            },
        )

    except subprocess.CalledProcessError as e:
        return {"message": f"Error running pipeline: {e}"}


@app.get("/download/{filename}")
async def download_file(filename: str):
    """
    Provides a way to download the result file (e.g., PDF or JSON).
    """
    file_path = UPLOAD_DIR / filename
    if not file_path.exists():
        return {"message": "File not found."}

    # Return the file as a download
    return FileResponse(
        file_path, media_type="application/octet-stream", filename=filename
    )
