import subprocess
import json
from fastapi import FastAPI, UploadFile, File, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from pathlib import Path

app = FastAPI()

templates = Jinja2Templates(directory="app/templates")
app.mount("/static", StaticFiles(directory="app/static"), name="static")

UPLOAD_DIR = Path("app/static/uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

# Directory for output results
OUTPUT_DIR = Path("data/output")
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# Absolute path to the btpipe.sh script
PIPELINE_SCRIPT_PATH = Path("app/btpipe.sh").absolute()


@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})


@app.post("/upload/")
async def upload_image(request: Request, file: UploadFile = File(...)):
    # Save the uploaded image
    file_path = UPLOAD_DIR / file.filename
    with open(file_path, "wb") as f:
        f.write(await file.read())

    # Log file details
    print(f"Received file: {file.filename}")
    print(f"File extension: {file.filename.split('.')[-1].lower()}")
    print("file_path", str(file_path))

    output_json_file = OUTPUT_DIR / "results.json"

    try:
        # Run the btpipe.sh script with the image path
        result = subprocess.run(
            ["bash", str(PIPELINE_SCRIPT_PATH), str(file_path)],
            text=True,
            capture_output=True,
        )

        # Log the output of the subprocess
        print(f"STDOUT:\n{result.stdout}")
        print(f"STDERR:\n{result.stderr}")

        if result.returncode != 0:
            return {"message": f"Pipeline execution failed. Error: {result.stderr}"}

        # Read the JSON file generated by bt2.py
        if not output_json_file.exists():
            return {
                "message": "Text Analysis model did not generate the expected output."
            }

        with open(output_json_file, "r") as f:
            output_data = json.load(f)

        # Render the results page
        return templates.TemplateResponse(
            "result.html",
            {
                "request": request,
                "image_path": file.filename,
                "analysis": output_data.get("analysis", ""),
                "summary": output_data.get("summary", ""),
            },
        )

    except subprocess.CalledProcessError as e:
        return {"message": f"Error running pipeline: {e}"}
